/*
    Testbench for verification and performance analysis of im2col algorithm.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <im2colGolden.h>
#include <x-heep.h>
#include <math.h>
#include "csr.h"

// Macro for accessing matrix elements
#define A(i,j) &A[i*SIZE+j]
#define B(i,j) &B[i*SIZE+j]
#define C(i,j) &C[i*SIZE+j]

// Select between the CPU (default-0), the standard DMA (1) or the multichannel DMA (2)
// TO-BE-IMPLEMENTED

#define HW_IMPLEMENTATION 0

/*
    Function prototypes
*/

// Implements the im2col algorithm using the selected HW
// Input is an image, i.e. a 3 channel tensor randomly generated by "verification_script.py"
void im2col(uint32_t *** input, uint32_t ** output, uint16_t channels, uint16_t patches_h, uint16_t patches_w, uint16_t filter_h, uint16_t filter_w, uint16_t stride);

// Verifies the im2col using golden values generated by "verification_script.py"
uint16_t verify(uint32_t ** output_tbt, uint32_t ** output_golden, uint16_t OH, uint16_t OW);

// Calculates the number of times a filter can slide into an input tensor
void patches(uint16_t input_w, uint16_t input_h, uint16_t filter_w, uint16_t filter_h, uint16_t stride, uint16_t padding, uint16_t * patches_w, uint16_t * patches_h);

// Modify the input tensor by performing zero padding
//void padding(uint32_t * input, uint16_t padding, );

// Calculates the size of the output of the im2col, depending on the filter parameters
void size_im2col(uint16_t patches_w, uint16_t patches_h, uint16_t filter_w, uint16_t filter_h, uint16_t channels, uint16_t stride, uint16_t padding, uint16_t * OH, uint16_t * OW);

/*
    Variables
*/

uint32_t ** output_im2col;

int main()
{
    uint16_t errors, OH, OW, n_patches_h, n_patches_w;
    unsigned int instr, cycles;
    exit(0);
    //enable mcycle csr
    CSR_CLEAR_BITS(CSR_REG_MCOUNTINHIBIT, 0x1);

    CSR_WRITE(CSR_REG_MCYCLE, 0);

    patches(IW, IH, FW, FH, S, P, &n_patches_w, &n_patches_h);
    
    size_im2col(n_patches_w, n_patches_h, FW, FH, CH, S, P, &OH, &OW);

    im2col(input_image, output_im2col, CH, n_patches_h, n_patches_w, FH, FW, S);

    errors = verify(output_im2col, golden_im2col, OH, OW);

    CSR_READ(CSR_REG_MCYCLE, &cycles);

    if (errors != 0)
    {
        printf("Im2col test FAILED with %d errors.\n");
    } 
    else 
    {
        printf("Im2col test PASSED!\n");
    }

    printf("Performance anlysis: this iteration lastes %d cycles\n\n", cycles);

}

void im2col(uint32_t *** input, uint32_t ** output, uint16_t channels, uint16_t patches_h, uint16_t patches_w, uint16_t filter_h, uint16_t filter_w, uint16_t stride)
{
    uint16_t column = 0, row = 0, i = 0, j = 0;
    for (uint16_t c = 0; c < CH; c++)
    {
        for (uint16_t u = 0; i < patches_h; i++) 
        {
            for (uint16_t v = 0; j < patches_w; j++)
            {
                for (uint16_t k = 0; k < filter_h; k++)
                {
                    for (uint16_t x = 0; x < filter_w; x++)
                    {
                        output[row][column] = input[c][i + k][j + x];
                        row++;
                    }                  
                }
                row -= filter_h * filter_w;
                column ++;  
                j += stride;
            }
            i += stride;
            j = 0; 
        }
        column = 0;
        i = 0;
        j = 0;
        row += filter_h * filter_w;
    }
}

void patches(uint16_t input_w, uint16_t input_h, uint16_t filter_w, uint16_t filter_h, uint16_t stride, uint16_t padding, uint16_t * patches_w, uint16_t * patches_h)
{
    *patches_h = (input_h + 2 * padding - filter_h)/ stride + 1;
    *patches_w = (input_w + 2 * padding - filter_w)/ stride + 1;

    return;
}

void size_im2col(uint16_t patches_w, uint16_t patches_h, uint16_t filter_w, uint16_t filter_h, uint16_t channels, uint16_t stride, uint16_t padding, uint16_t * OH, uint16_t * OW)
{
    *OW = filter_w * filter_h * channels;
    *OH = patches_h * patches_w;

    return;
}

uint16_t verify(uint32_t ** output_tbt, uint32_t ** output_golden, uint16_t OH, uint16_t OW)
{
    uint16_t errors = 0;

    for (uint16_t i=0; i<OH; i++)
    {
        for (uint16_t j=0; i<OW; j++)
        {
            if (output_golden[i][j] != output_im2col[i][j])
            {
                errors ++;
            }
        }
    }
    return errors;
}


