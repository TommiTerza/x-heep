/*
    Describes functions used to calculate im2col and verify it using 
    the golden result generated by verification_script.py.
    im2col_nchw_int32() and im2col_nhwc_int32() algorithm is taken from SHL by T-HEAD Semi. at:
    https://github.com/T-head-Semi/csi-nn2/blob/main/source/reference/im2col.c
*/

#include "im2col_lib.h"

uint32_t output_data[OH*OW];

int im2col_nchw_int32()
{
    #if DEBUG==2
    printf("OH: %d, OW: %d\n", OH, OW);
    #endif
    // Dimensions of the input tensor: batch size, number of channels, height, and width.
    int32_t batch = 1;
    int32_t channel = CH;
    int32_t height = IH;
    int32_t width = IW;

    // Extract the kernel size (height and width), stride (height and width) from the parameters.
    int32_t ksize_h = FH;
    int32_t ksize_w = FW;
    int32_t stride_h = S;
    int32_t stride_w = S;

    // Calculate the height and width of the output matrix (column) based on the input dimensions, padding, kernel size, and stride.
    // This essentially calculates how many sliding window positions fit into the input dimensions.
    int patches_h = (height + P + P - ksize_h) / stride_h + 1;
    int patches_w = (width + P + P - ksize_w) / stride_w + 1;

    // Calculate the heigth of the output matrix
    int output_h = channel * ksize_h * ksize_w; 
    int counter = 0;

    // Exploit the CPU for im2col
    #if HW_CONFIG == 0
    
    // Iterate over each row of the output matrix.
    for (int c = 0; c < output_h; ++c) {
        // Calculate offsets within the kernel window.
        // These are used to move the filter around the input image

        int w_offset = c % ksize_w;  
        int h_offset = (c / ksize_w) % ksize_h;
        int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

        // Iterate over each batch.
        for (int32_t b = 0; b < batch; ++b) {
            // Iterate over each patch on the width of the input matrix.
            for (int h = 0; h < patches_h; ++h) {
                // Iterate over each patch on the heigth in the output matrix.
                for (int w = 0; w < patches_w; ++w) {
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - P;
                    int32_t im_col = w_offset + w * stride_w - P;

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((c * batch + b) * patches_h + h) * patches_w + w;
                    
                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_image[get_index(CH, IH, IW, b, im_c, im_row, im_col)];
                    }

                    counter ++;

                    #if DEBUG==1
                    if (counter == 50)
                    {
                        counter = 0;
                        printf("*");
                    }
                    #endif

                    #if DEBUG==2
                    printf("\r\n%d ", output_data[col_index]);
                    fflush(stdout);
                    #endif
                }
            }
            #if DEBUG==2
            printf("\n");
            #endif
        }
        
    }
    #elif HW_CONFIG == 1
    // Use DMA 1D for im2col
    // Iterate over each row of the output matrix.

    uint32_t* input_image_ptr = &input_image[0];
    uint32_t* output_data_ptr = &output_data[0];

    // Initialize the output buffer with zeros
    zeros(output_data, OH*OW);

    // The DMA is initialized (i.e. Any current transaction is cleaned.)
    dma_init(NULL);

    dma_config_flags_t res;

    dma_target_t tgt_src = {
                                .ptr        = input_image,
                                .inc_du     = 1,
                                .size_du    = height*width*channel,
                                .trig       = DMA_TRIG_MEMORY,
                                .type       = DMA_DATA_TYPE_WORD,
                                };
    dma_target_t tgt_dst = {
                                .ptr        = output_data_ptr,
                                .inc_du     = 1,
                                .size_du    = OH*OW,
                                .trig       = DMA_TRIG_MEMORY,
                                };

    dma_target_t tgt_addr = {
                                .ptr        = input_image_ptr,
                                .inc_du     = 1,
                                .size_du    = OH*OW,
                                .trig       = DMA_TRIG_MEMORY,
                                };

    dma_trans_t trans = {
                                .src        = &tgt_src,
                                .dst        = &tgt_dst,
                                .src_addr   = &tgt_addr,
                                .mode       = DMA_TRANS_MODE_SINGLE,
                                .win_du     = 0,
                                .end        = DMA_TRANS_END_INTR,
                                };
    // Create a target pointing at the buffer to be copied. Whole WORDs, no skippings, in memory, no environment.


    for (int c = 0; c < output_h; ++c) {
        // Calculate offsets within the kernel window.
        // These are used to move the filter around the input image

        int w_offset = c % ksize_w;  
        int h_offset = (c / ksize_w) % ksize_h;
        int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

        // Iterate over each batch.
        for (int32_t b = 0; b < batch; ++b) {
            // Iterate over each patch on the width of the input matrix.
            for (int h = 0; h < patches_h; ++h) {

                // Iterate over each patch on the heigth in the output matrix.

                /* 
                    To optimize everything, this is the explicit input image index:
                    (B * CH + im_c) * IH + im_row * IW + im_col
                    (B * CH + c / (ksize_h * ksize_w)) * IH + (c / ksize_w) % ksize_h + h * stride_h - P * IW + c % ksize_w + w * stride_w - P
                    We can easyly calculate the next index by adding stride_w to the previous one! So its possible to set the DMA with a fixed 
                    loop increment!
                    Padding will happen if at least one of these conditions is met:
                    - im_row < 0 : It happens when we are sourcing from the first rows of the input image, which with padding
                        have been thoretically filled with zeros.
                        Since it's constant in the w loop, it can be calculated before calling the dma. There will be
                        patch_w zeros at the beginning of the row of the output matrix
                    - im_col < 0 : Happens when sourcing the first columns of the input image.
                        To compute how many iterations are needed to reach the first valid row, we can use the formula:
                                                    #zeros: abs(P - w_offset) / stride_w
                    - im_row >= height: Happens when sourcing from the last rows of the input image.
                        As before, it will write patch_w zeros in the output matrix.
                    - im_col >= width: Happens when sourcing from the last columns of the input image.
                        To compute how many iterations are needed to reach the last valid column, we can use the formula:
                                                    #zeros: abs(im_col - width + 1) / stride_w
                */

                /*
                    Because of the way this im2col is computed, it will always have:
                    - some zeros at the beginning of the w patch 
                    - numbers
                    - some zeros at the end of the w patch
                    So for each iteration of the h loop:
                    If im_row < 0:
                    - Set one DMA call in the case of im_row < 0, which will write w_patch zeros in the output matrix & update the output pointer
                    Elsif im_row >= height:
                    - Set one DMA call in the case of im_row >= height, which will write w_patch zeros & update the output pointer
                    Else:   
                        - Set one DMA call in the case of im_call < 0 (basically when P is more than 0), which will write (P - w_offset) / stride_w zeros & update the output pointer
                        - Set one DMA call for the normal case, which will copy the input image starting from the last point & update the output & input pointer
                            of the previous DMA call for patches_w times and with a step of stride_w
                        - Set one DMA call in the case of im_col >= width (basically when P is more than 0), which will write abs(im_col - width + 1) / stride_w zeros & update the output pointer

                    Even better: we could initialize the part of memory we want to use for the output matrix with zeros, and then we
                    can entirely avoid saving zeros, because they are already there!
                */

                if (h_offset + h * stride_h - P < 0)
                {
                    // im_row < 0 case: only the output_image_ptr needs to be updated
                    output_data_ptr += patches_w;
                } 
                else if (h_offset + h * stride_h - P > height)
                {
                    // im_row >= height case:
                    output_data_ptr += patches_w;
                }
                else
                {
                    if (P > 0)
                    {
                        // im_col < 0 case: only the output_image_ptr needs to be updated
                        output_data_ptr += (P - w_offset) / stride_w;
                    }

                    tgt_src.ptr = input_image_ptr;
                    tgt_src.size_du = patches_w;
                    tgt_src.inc_du = stride_w;

                    tgt_dst.ptr = output_data_ptr;
                    tgt_dst.size_du = patches_w;
                    
                    dma_run(&trans);
                    output_data_ptr += patches_w;
                    input_image_ptr += patches_w;

                    if (P > 0)
                    {
                        // im_col < 0 case: only the output_image_ptr needs to be updated
                        output_data_ptr += (P - w_offset) / stride_w;
                    }
                }

                dma_run(&trans);

                for (int w = 0; w < patches_w; ++w) {
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - P; // This is constant during the w loop
                    int32_t im_col = w_offset + w * stride_w - P; // This is increased by stride_w during the w loop !!

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((c * batch + b) * patches_h + h) * patches_w + w; // This is increased by 1 during the w loop !!!
                    
                    

                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_image[get_index(CH, IH, IW, b, im_c, im_row, im_col)];
                    }

                    counter ++;

                    #if DEBUG==1
                    if (counter == 50)
                    {
                        counter = 0;
                        printf("*");
                    }
                    #endif

                    #if DEBUG==2
                    printf("\r\n%d ", output_data[col_index]);
                    fflush(stdout);
                    #endif
                }
            }
            #if DEBUG==2
            printf("\n");
            #endif
        }
        
    }
    #elif HW_CONFIG == 2
    // Use DMA 2D for im2col
    #endif
    // Return a 1 to indicate a success
    return 1;
}

int im2col_nhwc_int32()
{
    #if DEBUG==2
    printf("OH: %d, OW: %d\n", OH, OW);
    #endif
    // Dimensions of the input tensor: batch size, number of channels, height, and width.
    int32_t batch = 1;
    int32_t channel = CH;
    int32_t height = IH;
    int32_t width = IW;

    // Extract the kernel size (height and width), stride (height and width) from the parameters.
    int32_t ksize_h = FH;
    int32_t ksize_w = FW;
    int32_t stride_h = S;
    int32_t stride_w = S;

    // Calculate the height and width of the output matrix (column) based on the input dimensions, padding, kernel size, and stride.
    // This essentially calculates how many sliding window positions fit into the input dimensions.
    int patches_h = (height + P + P - ksize_h) / stride_h + 1;
    int patches_w = (width + P + P - ksize_w) / stride_w + 1;

    // Calculate the heigth of the output matrix
    int output_h = channel * ksize_h * ksize_w; 
    int counter = 0;

    // Exploit the CPU for im2col
    #if HW_CONFIG == 0
    // Iterate over each row of the output matrix.
    for (int32_t b = 0; b < batch; ++b) {
        // Iterate over each batch.
        for (int h = 0; h < patches_h; ++h) {
            // Iterate over each patch on the width of the input matrix.
            for (int w = 0; w < patches_w; ++w) {
                // Iterate over each patch on the heigth in the output matrix.
                for (int c = 0; c < output_h; ++c) {
                    // Calculate offsets within the kernel window.
                    // These are used to move the filter around the input image

                    int w_offset = c % ksize_w;  
                    int h_offset = (c / ksize_w) % ksize_h;
                    int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

                    
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - P;
                    int32_t im_col = w_offset + w * stride_w - P;

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((b * patches_h + h) * patches_w + w) * output_h + c; //  ((c * batch + b) * patches_h + h) * patches_w + w;
                    
                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_image[get_index(IH, IW, CH, b, im_row, im_col, im_c)];
                    }

                    counter ++;

                    #if DEBUG==1
                    if (counter == 50)
                    {
                        counter = 0;
                        printf("*");
                    }
                    #endif


                    #if DEBUG==2
                    printf("\r%d ", output_data[col_index]);
                    fflush(stdout);
                    #endif
                }
            }
            #if DEBUG==2
            printf("\n");
            #endif
        }
    }
    #elif HW_CONFIG == 1

    // Use DMA 1D for im2col
    #elif HW_CONFIG == 2
    // Use DMA 2D for im2col
    #endif
    // Return a 1 to indicate a success
    return 1;
}

int32_t get_index(int32_t dim1, int32_t dim2, int32_t dim3, int32_t index0, int32_t index1, int32_t index2,
                          int32_t index3)
{
    return ((index0 * dim1 + index1) * dim2 + index2) * dim3 + index3;
}

// Verifies the im2col using golden values generated by "verification_script.py"
uint16_t verify()
{
    uint16_t errors = 0;

    for (uint16_t i=0; i<OH; i++)
    {
        for (uint16_t j=0; j<OW; j++)
        {    
            if (golden_im2col[i*OW + j] != output_data[i*OW + j])
            {
                
                errors ++;
            }
        }
    }
    return errors;
}

void dma_run(dma_trans_t * trans)
{
    int res = dma_validate_transaction(trans, DMA_ENABLE_REALIGN, DMA_PERFORM_CHECKS_INTEGRITY );
    PRINTF("tran: %u \t%s\n\r", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");
    res = dma_load_transaction(&trans);
    PRINTF("load: %u \t%s\n\r", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");
    res = dma_launch(&trans);
    PRINTF("laun: %u \t%s\n\r", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");

    while( ! dma_is_ready()) {
        // disable_interrupts
        // this does not prevent waking up the core as this is controlled by the MIP register
        CSR_CLEAR_BITS(CSR_REG_MSTATUS, 0x8);
        if ( dma_is_ready() == 0 ) {
            wait_for_interrupt();
            //from here we wake up even if we did not jump to the ISR
        }
        CSR_SET_BITS(CSR_REG_MSTATUS, 0x8);
    }
    return;
}

void zeros(uint32_t* ptr, uint32_t size)
{
    for (uint32_t i=0; i<size; i++)
    {
        ptr[i] = 0;
    }
}