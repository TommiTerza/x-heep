/*
    Describes functions used to calculate im2col and verify it using 
    the golden result generated by verification_script.py.
    im2col_nchw_int32() and im2col_nhwc_int32() algorithm is taken from SHL by T-HEAD Semi. at:
    https://github.com/T-head-Semi/csi-nn2/blob/main/source/reference/im2col.c
*/

#include "im2col_lib.h"

uint32_t output_data[OH*OW];

int im2col_nchw_int32()
{
    #if DEBUG==2
    printf("%d %d\n", OH, OW);
    #endif
    // Dimensions of the input tensor: batch size, number of channels, height, and width.
    int32_t batch = B;
    int32_t channel = CH;
    int32_t height = IH;
    int32_t width = IW;

    // Extract the kernel size (height and width), stride (height and width) from the parameters.
    int32_t ksize_h = FH;
    int32_t ksize_w = FW;
    int32_t stride_h = S;
    int32_t stride_w = S;

    // Calculate the height and width of the output matrix (column) based on the input dimensions, padding, kernel size, and stride.
    // This essentially calculates how many sliding window positions fit into the input dimensions.
    int patches_h = (height + P + P - ksize_h) / stride_h + 1;
    int patches_w = (width + P + P - ksize_w) / stride_w + 1;

    // Calculate the heigth of the output matrix
    int output_h = channel * ksize_h * ksize_w; 
    int counter = 0;

    // Exploit the CPU for im2col
    #if HW_CONFIG == 0
    
    // Iterate over each row of the output matrix.
    for (int c = 0; c < output_h; ++c) {
        // Calculate offsets within the kernel window.
        // These are used to move the filter around the input image

        int w_offset = c % ksize_w;  
        int h_offset = (c / ksize_w) % ksize_h;
        int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

        // Iterate over each batch.
        for (int32_t b = 0; b < batch; ++b) {
            // Iterate over each patch on the width of the input matrix.
            for (int h = 0; h < patches_h; ++h) {
                // Iterate over each patch on the heigth in the output matrix.
                for (int w = 0; w < patches_w; ++w) {
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - P;
                    int32_t im_col = w_offset + w * stride_w - P;

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((c * batch + b) * patches_h + h) * patches_w + w;
                    
                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_image[get_index(CH, IH, IW, b, im_c, im_row, im_col)];
                        #if DEBUG==2
                        printf("\n%d ", get_index(CH, IH, IW, b, im_c, im_row, im_col));
                        fflush(stdout);
                        #endif
                    }

                    counter ++;

                    #if DEBUG==1
                    if (counter == 50)
                    {
                        counter = 0;
                        printf("*");
                    }
                    #endif

                    #if DEBUG==2
                    printf("\n%d ", output_data[col_index]);
                    fflush(stdout);
                    #endif
                }
            }
            #if DEBUG==2
            printf("\n");
            #endif
        }
        
    }
    #elif HW_CONFIG == 1
    // Use DMA 1D for im2col
    // Iterate over each row of the output matrix.

    uint32_t* input_image_ptr = &input_image[0];
    uint32_t* output_data_ptr = &output_data[0];

    // The DMA is initialized (i.e. Any current transaction is cleaned.)
    dma_init(NULL); // NULL becaus ewe want to use the integrated DMA

    dma_config_flags_t res;

    dma_target_t tgt_src = {
                                .ptr        = input_image,
                                .inc_du     = 1,
                                .size_du    = height*width*channel,
                                };
    dma_target_t tgt_dst = {
                                .ptr        = output_data_ptr,
                                .inc_du     = 1
                                };

    dma_trans_t trans = {
                                .src        = &tgt_src,
                                .dst        = &tgt_dst
                                };

    uint32_t* ptr; 

    // Create a target pointing at the buffer to be copied. Whole WORDs, no skippings, in memory, no environment.
    #if DEBUG==2    
    printf("\n* %p", output_data_ptr);
    fflush(stdout);
    #endif

    for (int c = 0; c < output_h; ++c) {
        // Calculate offsets within the kernel window.
        // These are used to move the filter around the input image

        int w_offset = c % ksize_w;  // the offset ALONG the width
        int h_offset = (c / ksize_w) % ksize_h; // the ofset ALONG the height
        int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

        // Iterate over each batch.
        for (int32_t b = 0; b < batch; ++b) {
            // Iterate over each patch on the width of the input matrix.
            for (int h = 0; h < patches_h; ++h) {

                int32_t im_row = h_offset + h * stride_h - P;

                int32_t im_col = w_offset - P;

                char zeros_before = 0;
                char zeros_after = 0;

                int n_zeros_before = 0;
                int n_zeros_after = 0;
                int tot_acquisitions = 0;

                int size_transfer = 0;

                #if DEBUG==2    
                printf("\nim_row: %d, im_col: %d", im_row, im_col);
                printf("\nw_offset: %d, h_offset: %d\n", w_offset, h_offset);
                #endif

                // Iterate over each patch on the heigth in the output matrix.

                /* 
                    To optimize everything, this is the explicit input image index:
                    b, im_c, im_row, im_col
                    ((index0 * dim1 + index1) * dim2 + index2) * dim3 + index3
                    ((b * CH + im_c) * IH + im_row) * IW + im_col
                    ((b * CH + c / (ksize_h * ksize_w)) * IH + h_offset + h * stride_h - P) * IW + w_offset + w * stride_w - P

                    (B * CH + c / (ksize_h * ksize_w)) * IH + (c / ksize_w) % ksize_h + h * stride_h - P * IW + c % ksize_w + w * stride_w - P
                    We can easyly calculate the next index by adding stride_w to the previous one! So its possible to set the DMA with a fixed 
                    loop increment!
                    Padding will happen if at least one of these conditions is met:
                    - im_row < 0 : It happens when we are sourcing from the first rows of the input image, which with padding
                        have been thoretically filled with zeros.
                        Since it's constant in the w loop, it can be calculated before calling the dma. There will be
                        patch_w zeros at the beginning of the row of the output matrix
                    - im_col < 0 : Happens when sourcing the first columns of the input image.
                        To compute how many iterations are needed to reach the first valid row, we can use the formula:
                                                    #zeros: abs(P - w_offset) / stride_w
                    - im_row >= height: Happens when sourcing from the last rows of the input image.
                        As before, it will write patch_w zeros in the output matrix.
                    - im_col >= width: Happens when sourcing from the last columns of the input image.
                        To compute how many iterations are needed to reach the last valid column, we can use the formula:
                                                    #zeros: abs(im_col - width + 1) / stride_w
                */

                /*
                    Because of the way this im2col is computed, it will always have:
                    - some zeros at the beginning of the w patch 
                    - numbers
                    - some zeros at the end of the w patch
                    So for each iteration of the h loop:
                    If im_row < 0:
                    - Set one DMA call in the case of im_row < 0, which will write w_patch zeros in the output matrix & update the output pointer
                    Elsif im_row >= height:
                    - Set one DMA call in the case of im_row >= height, which will write w_patch zeros & update the output pointer
                    Else:   
                        - Set one DMA call in the case of im_call < 0 (basically when P is more than 0), which will write (P - w_offset) / stride_w zeros & update the output pointer
                        - Set one DMA call for the normal case, which will copy the input image starting from the last point & update the output & input pointer
                            of the previous DMA call for patches_w times and with a step of stride_w
                        - Set one DMA call in the case of im_col >= width (basically when P is more than 0), which will write abs(im_col - width + 1) / stride_w zeros & update the output pointer

                    Even better: we could initialize the part of memory we want to use for the output matrix with zeros, and then we
                    can entirely avoid saving zeros, because they are already there! 
                    Initialize is actually a memory access, but the memory is by default wiped out, 
                    so it may be a useless step.
                */
                

                if (P>0 && im_row < 0)
                {
                    // im_row < 0 case: only the output_image_ptr needs to be updated
                    output_data_ptr += patches_w;
                    #if DEBUG==2    
                    printf("\nAdded the initial full row of 0s, %d elements", patches_w);
                    fflush(stdout);
                    #endif
                } 
                else if (P>0 && im_row >= width)
                {
                    // im_row >= height case:
                    output_data_ptr += patches_w;
                    #if DEBUG==2    
                    printf("\nAdded the final full row of 0s, %d elements", patches_w);
                    fflush(stdout);
                    #endif
                }
                else
                {
                    // Computing the total number of times the filter can be applied to the initial zeros padded part of the row
                    // considering the fact that the filter can be applied partially because after the 0s of course there is the image itself
                    tot_acquisitions = (P - 1)/(stride_w) + 1;
                    n_zeros_before = (w_offset >= P - (tot_acquisitions - 1) * stride_w) ? tot_acquisitions -1 : tot_acquisitions;
                    // abs(P - w_offset) / stride_w;

                    // Computing the total number of times the filter can be applied to the final zeros padded part of the row,
                    // now considering the fact that the filter in this case must be applied completely, because of course after the 0s the image ends
                    tot_acquisitions = (P - ksize_w)/(stride_w) + 1;
                    n_zeros_after = (ksize_w - 1 - w_offset >= P - (tot_acquisitions - 1) * stride_w) ? tot_acquisitions -1: tot_acquisitions;
                    // abs(P - (ksize_w - 1 - w_offset)  ) / stride_w;
                    /*
                    if ((P - w_offset) > 0 && (P - w_offset) < stride_w)
                    {
                        n_zeros_before = 1;
                    }

                    if ((P - (ksize_w - 1 - w_offset)) > 0 && (P - (ksize_w - 1 - w_offset)) < stride_w)
                    {
                        n_zeros_after = 1;
                    }
                    */

                    #if DEBUG==2
                    printf("\nzeros_befor:%d zeros_after:%d tot_acquisitions:%d", n_zeros_before, n_zeros_after, tot_acquisitions);  
                    #endif

                    size_transfer = patches_w - n_zeros_before - n_zeros_after;

                    if (n_zeros_before > 0)
                    {
                        // im_col < 0 case: only the output_image_ptr needs to be updated
                        output_data_ptr += n_zeros_before;

                        #if DEBUG==2    
                        printf("\nAdded %d '0's before",  n_zeros_before);
                        #endif

                        im_col += n_zeros_before * stride_w;
                    }

                    input_image_ptr = &input_image[0] + get_index(CH, IH, IW, b, im_c, im_row, im_col);
                    tgt_src.ptr = input_image_ptr;
                    tgt_src.size_du = size_transfer;
                    tgt_src.inc_du = stride_w;

                    tgt_dst.ptr = output_data_ptr;
                    tgt_dst.size_du = size_transfer;
                    
                    dma_run(&trans);

                    ptr = output_data_ptr;

                    #if DEBUG==2
                    printf("\nWrote %d elements from input", tgt_src.size_du);
                    for (int i=0; i<tgt_src.size_du/sizeof(uint32_t); i++)
                    {
                        printf("\n%p %d", ptr, *ptr);
                        fflush(stdout);
                        ptr += 1;
                    }
                    #endif

                    output_data_ptr += size_transfer;

                    #if DEBUG==4
                    printf("\n%d", im_col + (patches_w-1) * stride_w);
                    #endif

                    if (n_zeros_after > 0)
                    {
                        // im_col < 0 case: only the output_image_ptr needs to be updated
                        output_data_ptr += n_zeros_after;
                        #if DEBUG==2    
                        printf("\nAdded %d '0's after",  n_zeros_after);
                        fflush(stdout);
                        #endif
                    }
                    #if DEBUG==2    
                    printf("\n");
                    fflush(stdout);
                    #endif
                }
                #if DEBUG==2
                printf("\nCurrent output matrix: \n");
                for (int i=0; i<OH; i++)
                {
                    for (int j=0; j<OW; j++)
                    {
                        #if DEBUG==3 || DEBUG==2 || DEBUG==1
                        printf("%d ", output_data[i*OW + j]);
                        #endif
                    }
                    printf("\n");
                }
                #endif
                }
                #if DEBUG==2
                printf("\n");
                #endif
            }
        
    }
    #elif HW_CONFIG == 2
    // Use DMA 2D for im2col
    #endif

    // Finished!

    #if DEBUG==3 || DEBUG==2 || DEBUG==1
    printf("Final output matrix:\n\n");
    #endif

    for (int i=0; i<OH; i++)
    {
        for (int j=0; j<OW; j++)
        {
            #if DEBUG==3 || DEBUG==2 || DEBUG==1
            printf("%d ", output_data[i*OW + j]);
            #endif
        }
        printf("\n");
    }

    // Return a 1 to indicate a success
    return 1;
}

int im2col_nhwc_int32()
{
    #if DEBUG==2
    printf("OH: %d, OW: %d\n", OH, OW);
    #endif
    // Dimensions of the input tensor: batch size, number of channels, height, and width.
    int32_t batch = 1;
    int32_t channel = CH;
    int32_t height = IH;
    int32_t width = IW;

    // Extract the kernel size (height and width), stride (height and width) from the parameters.
    int32_t ksize_h = FH;
    int32_t ksize_w = FW;
    int32_t stride_h = S;
    int32_t stride_w = S;

    // Calculate the height and width of the output matrix (column) based on the input dimensions, padding, kernel size, and stride.
    // This essentially calculates how many sliding window positions fit into the input dimensions.
    int patches_h = (height + P + P - ksize_h) / stride_h + 1;
    int patches_w = (width + P + P - ksize_w) / stride_w + 1;

    // Calculate the heigth of the output matrix
    int output_h = channel * ksize_h * ksize_w; 
    int counter = 0;

    // Exploit the CPU for im2col
    #if HW_CONFIG == 0
    // Iterate over each row of the output matrix.
    for (int32_t b = 0; b < batch; ++b) {
        // Iterate over each batch.
        for (int h = 0; h < patches_h; ++h) {
            // Iterate over each patch on the width of the input matrix.
            for (int w = 0; w < patches_w; ++w) {
                // Iterate over each patch on the heigth in the output matrix.
                for (int c = 0; c < output_h; ++c) {
                    // Calculate offsets within the kernel window.
                    // These are used to move the filter around the input image

                    int w_offset = c % ksize_w;  
                    int h_offset = (c / ksize_w) % ksize_h;
                    int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

                    
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - P;
                    int32_t im_col = w_offset + w * stride_w - P;

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((b * patches_h + h) * patches_w + w) * output_h + c; //  ((c * batch + b) * patches_h + h) * patches_w + w;
                    
                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_image[get_index(IH, IW, CH, b, im_row, im_col, im_c)];
                    }

                    counter ++;

                    #if DEBUG==1
                    if (counter == 50)
                    {
                        counter = 0;
                        printf("*");
                    }
                    #endif


                    #if DEBUG==2
                    printf("%d ", output_data[col_index]);
                    fflush(stdout);
                    #endif
                }
            }
            #if DEBUG==2
            printf("\n");
            #endif
        }
    }
    #elif HW_CONFIG == 1

    // Use DMA 1D for im2col
    #elif HW_CONFIG == 2
    // Use DMA 2D for im2col
    #endif
    // Return a 1 to indicate a success
    return 1;
}

int32_t get_index(int32_t dim1, int32_t dim2, int32_t dim3, int32_t index0, int32_t index1, int32_t index2,
                          int32_t index3)
{
    return ((index0 * dim1 + index1) * dim2 + index2) * dim3 + index3;
}

// Verifies the im2col using golden values generated by "verification_script.py"
uint16_t verify()
{
    uint16_t errors = 0;

    for (uint16_t i=0; i<OH; i++)
    {
        for (uint16_t j=0; j<OW; j++)
        {    
            if (golden_im2col[i*OW + j] != output_data[i*OW + j])
            {
                #if DEBUG==2    
                printf("ERROR: Golden: %d, Output: %d, at %d %d\n", golden_im2col[i*OW + j], output_data[i*OW + j], i, j);
                #endif
                errors ++;
            }
        }
    }
    return errors;
}

void dma_run(dma_trans_t * trans)
{
    int res = dma_validate_transaction(trans, DMA_ENABLE_REALIGN, DMA_PERFORM_CHECKS_INTEGRITY );
    //PRINTF("tran: %u \t%s\n", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");
    res = dma_load_transaction(trans);
    //PRINTF("load: %u \t%s\n", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");
    res = dma_launch(trans);
    //PRINTF("laun: %u \t%s\n", res, res == DMA_CONFIG_OK ?  "Ok!" : "Error!");

    while( ! dma_is_ready()) {
        // disable_interrupts
        // this does not prevent waking up the core as this is controlled by the MIP register
        CSR_CLEAR_BITS(CSR_REG_MSTATUS, 0x8);
        if ( dma_is_ready() == 0 ) {
            wait_for_interrupt();
            //from here we wake up even if we did not jump to the ISR
        }
        CSR_SET_BITS(CSR_REG_MSTATUS, 0x8);
    }

    return;
}
