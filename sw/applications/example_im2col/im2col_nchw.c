// Defines a function to perform the "im2col" operation for a 4D input tensor in NCHW format (batch, channel, height, width) 
// using floating-point precision.
// This operation is commonly used in convolutional neural networks to transform the input image into columns before 
// matrix multiplication.
// Parameters:
// - input: Pointer to the input tensor structure containing the image data.
// - output: Pointer to the output tensor structure where the transformed data will be stored.
// - params: Pointer to the structure containing the parameters for the im2col operation such as kernel size, stride, and padding.

#include <im2col_nchw.h>

static int im2col_nchw_f32(struct tensor *input, struct tensor *output,
                                   struct im2col_params *params)
{
    // Retrieve the pointer to the input data casted to float, assuming the input data is stored in floating-point format.
    uint32_t *input_data = (uint32_t *)input->data;
    // Retrieve the pointer to the output data casted to float.
    uint32_t *output_data = (uint32_t *)output->data;

    // Extract dimensions from the input tensor: batch size, number of channels, height, and width.
    int32_t batch = input->dim[0];
    int32_t channel = input->dim[1];
    int32_t height = input->dim[2];
    int32_t width = input->dim[3];

    // Extract the kernel size (height and width), stride (height and width) from the parameters.
    int32_t ksize_h = params->kernel_h;
    int32_t ksize_w = params->kernel_w;
    int32_t stride_h = params->stride_h;
    int32_t stride_w = params->stride_w;

    // Calculate the height and width of the output matrix (column) based on the input dimensions, padding, kernel size, and stride.
    // This essentially calculates how many sliding window positions fit into the input dimensions.
    int patches_h = (height + params->pad_top + params->pad_down - ksize_h) / stride_h + 1;
    int patches_w = (width + params->pad_left + params->pad_right - ksize_w) / stride_w + 1;

    // Calculate the total number of channels in the output matrix, factoring in the kernel size.
    // In other words, it calculates the H of the output matrix
    int output_h = channel * ksize_h * ksize_w; 

    // Iterate over each channel of the output matrix.
    for (int c = 0; c < output_h; ++c) {
        // Calculate offsets within the kernel window.
        // These are used to move the filter around in the input image

        int w_offset = c % ksize_w;  
        int h_offset = (c / ksize_w) % ksize_h;
        int32_t im_c = c / (ksize_h * ksize_w); // Gets the channel on which the im2col is being performed depending on the row of the output image (c)

        // Iterate over each batch.
        for (int32_t b = 0; b < batch; ++b) {
            // Iterate over each w patch in the output matrix.
            for (int h = 0; h < patches_h; ++h) {
                // Iterate over each h patch in the output matrix.
                for (int w = 0; w < patches_w; ++w) {
                    // Calculate the row and column indices in the original input image, applying the stride and offset.
                    int32_t im_row = h_offset + h * stride_h - params->pad_top;
                    int32_t im_col = w_offset + w * stride_w - params->pad_left;

                    // Calculate the index in the flattened output array where this value should be stored.
                    int32_t col_index = ((c * batch + b) * patches_h + h) * patches_w + w;
                    printf("col_index: %d\n", col_index);
                    // If the calculated indices are outside the bounds of the input image, set the output to 0 (padding effect).
                    // Otherwise, fetch the value from the input image and store it in the output array.
                    if (im_row < 0 || im_col < 0 || im_row >= height || im_col >= width) {
                        output_data[col_index] = 0;
                    } else {
                        output_data[col_index] = input_data[get_index(input->dim, b, im_c, im_row, im_col)];
                    }
                }
            }
        }
    }
    // Return a 1 to indicate a success
    return 1;
}

int32_t get_index(int32_t *dim, int32_t index0, int32_t index1, int32_t index2,
                          int32_t index3)
{
    return ((index0 * dim[1] + index1) * dim[2] + index2) * dim[3] + index3;
}

// Verifies the im2col using golden values generated by "verification_script.py"
uint16_t verify(uint32_t * output_tbt, uint16_t * output_gold, uint16_t OH, uint16_t OW)
{
    uint16_t errors = 0;

    for (uint16_t i=0; i<OH; i++)
    {
        for (uint16_t j=0; i<OW; j++)
        {
            if (output_gold[i*OH + j] != output_tbt[i*OH + j])
            {
                errors ++;
            }
        }
    }
    return errors;
}