# Integrate Peripherals

This documentation file summarizes how to integrate a hardware peripheral in the _x-heep_ platform.

## 1. Create the IP Structure
This is how the folder should look like:

```  
hw/ip/<peripheral>
    ├── data/
    │   └──<peripheral>.hjson           # register description (for regtool generation)
    ├── rtl/
    │   ├──<peripheral>.sv              # RTL of the peripheral
    │   ├── <peripheral>_reg_top.sv     # generated by regtool
    │   └── <peripheral>_reg_pkg.sv     # generated by regtool
    ├── <peripheral>.core               # FuseSoC description
    ├── <peripheral>.vlt                # Verilator waiver
    └── <peripheral>_gen.sh             # helper script running regtool
```

#### X-HEEP-compatible module ports

All X-HEEP peripheral modules require specific ports that allows it to communicate with the rest of the system. 

The following is the absolute minimum starting point to develop your peripheral module ports:

```systemverilog
module peripheral (
    input logic clk_i,
    input logic rst_ni,

    // Register interface
    input reg_pkg::reg_req_t reg_req_i,
    output reg_pkg::reg_rsp_t reg_rsp_o
);
```

The CPU can access the configuration registers of the peripheral via the register interface:
- `reg_req_i` is the input request, which can either request to write some value into a register or read values from a register
- `reg_rsp_o` is the output response, which may contains register data if the request was a read operation

In any case, the implementation of this protocol is transparent to the RTL designer, as its included in the **top register module** generated via regtool depending on the `data/<peripheral>.hjson` information.

Here is an extended example of a module port structure which includes additional features:

```systemverilog
module peripheral (
    input logic clk_i,
    input logic rst_ni,

    // Register interface
    input reg_pkg::reg_req_t reg_req_i,
    output reg_pkg::reg_rsp_t reg_rsp_o,

    // Done signal
    output logic peripheral_done_o,

    // Interrupt signal
    output logic peripheral_interrupt_o,

    // Master ports on the system bus
    output obi_req_t  peripheral_master_bus_req_o,
    input  obi_resp_t peripheral_master_bus_resp_i
);
```

About the additional features:
- `peripheral_done_o`: this done signal could be useful if you want X-HEEP to expose it, so that external units can be aware of it. For example, each X-HEEP's DMA channel exposes a `dma_done_o` signal. This could be used for example by accelerators that exploit the DMA functionalities to move data in and out of their local memory 

- `peripheral_interrupt_o`: this signal can be used to set up a dedicated interrupt line reserved for your peripheral. This would allow the execution of custom interrupt handlers in SW, a common and useful feature.

- `peripheral_master_bus_req_o / peripheral_master_bus_resp_i`: these are OBI request and response signals, necessary if you want your peripheral to be a master on the system bus. In other words, this would allow your peripheral to read and write data in every memory mapped space of X-HEEP. For example, this could allow your peripheral to read from RAM, or it could allow it to configure other peripherals.


## 2. Describe and Generate Registers
In X-HEEP, registers are automatically generated using RegTool by OpenTitan. See [Open Titan IP guide](OpenTitanIP.md) for more details.
In anycase, this tool will generate both RTL and SW components starting from an HJSON description. These are the steps needed to set everything up:

1. Populate `data/<peripheral>.hjson` with registers, fields, reset values, and optional interrupts. DLC’s [`dlc.hjson`](../../../hw/ip_examples/dlc/data/dlc.hjson) is a good example, but you could take inspiration from any X-HEEP `.hjson`.
2. Generate RTL wrappers and the C header files by running the `<peripheral>_gen.sh` script.

## 3. Expose the IP to FuseSoC
This is a crucial step in integrating the new peripheral in X-HEEP's flow:

1. Adapt `hw/ip/<peripheral>/<peripheral>.core` from [`dlc.core`](../../../hw/ip_examples/dlc/dlc.core). List all RTL files under `files:` and declare dependencies (for example `pulp-platform.org::register_interface`).
2. Add the peripheral as a dependency of the SoC in `core-v-mini-mcu.core`:
   ```yaml
   filesets:
     files_rtl_generic:
       depend:
         - example:ip:<peripheral>  # use the namespace chosen in your .core file
   ```
3. If the IP has lint waivers for Verilator, reference the waiver in the `.core` file:
   ```yaml
   filesets:
     depend:
      - openhwgroup.org:ip:verilator_waiver
     files:
      - hw/ip/<peripheral>/<peripheral>.vlt  # use the namespace chosen in your .core file
   ```

## 4. Reserve Address Space in the Configuration
This is another crucial step in the integration of the peripheral. Please be aware that the address map of X-HEEP might change in the future, so consider this for the addresses of the following examples.
As said at the beginning of this guide, these steps are the same for any domain you want to integrate the perihperal in, both `user peripherals` and `base peripherals`.

1. Extend the configuration you built (HJSON or Python) with a new entry in the preferred domain. Example (`configs/general.hjson`):
   ```hjson
   peripherals: {
       address: 0x30000000
       length:  0x00100000
       // existing peripherals…
       <peripheral>: {
           offset:  0x00080000
           length:  0x00010000
           path:    "./hw/ip/<peripheral>/data/<peripheral>.hjson"
           is_included: "yes"
       }
       // existing peripherals…
   }
   ```
2. For Python configs, import a new class in `util/x_heep_gen/peripherals/user_peripherals.py` (or `base_peripherals.py` if mandatory):
   ```python
   class <peripheral>(UserPeripheral, DataConfiguration):
       _name = "<peripheral>"
       _config_path = "./hw/ip/<peripheral>/data/<peripheral>.hjson"
   ```
   Instantiate the class in your config script and add it to the user domain before calling `build()`.
3. If your IP generates an interrupt signal, extend the _interrupt list_ with it.

```{warning}
When a file has a template (another file that has the same name but with a `.tpl` extension), this file is auto-generated. Therefore, do only edit the template file. Otherwise, the modifications will be overriden at the platform generation.
```

4. In case of modification of the GPIOs usage, the `hw/fpga/xilinx_core_v_mini_mcu_wrapper.sv` must be adapted.

a. In the `x_heep_system_i` instance, GPIOs can be replaced by the desired signals:

```diff
-      .gpio_X_io(gpio_io[X]),
+      .your_signal_io(your_signal_io),
```

b. The module `xilinx_core_v_mini_mcu_wrapper` should be modified as follows:

```diff
+    inout  logic your_signal_io,

-    inout logic [X:0] gpio_io,
+    inout logic [X-1:0] gpio_io,
```

c. The pads configuration (pad_cfg.hjson) must be adapted as well:

```diff
         gpio: {
-            num: <N>
+            num: <N-D>
             num_offset: 0 # first gpio is gpio0
             type: inout
         }
+        pdm2pcm_pdm: {
+            num: 1
+            type: inout
+            mux: {
+                <peripheral_io>: {
+                    type: inout
+                },
+                gpio_K: {
+                    type: inout
+                }
+            }
+        }
```

5. The peripheral subsystem (`hw/core-v-mini-mcu/peripheral_subsystem.sv`) must also be adapted:

I. The I/O signals can be added in the `peripheral_subsystem` module:

```systemverilog
    inout  logic your_signal_io,
```

II. The module must be instantiated in the peripheral subsystem:

```systemverilog
  <peripheral> #(
      .reg_req_t(reg_pkg::reg_req_t),
      .reg_rsp_t(reg_pkg::reg_rsp_t)
  ) <peripheral>_i (
      .clk_i,
      .rst_ni,
      <...>
  );
```

6. The core MCU I/O must be adapted as well (`hw/core-v-mini-mcu/core_v_mini_mcu.sv.tpl`). Add the I/Os to the peripherals subsystem instanciation:

```diff
  peripheral_subsystem #(
      <...>
  ) peripheral_subsystem_i (
      <...>
+      .your_signal_io(your_signal_io),
      <...>
  );
```

7. The peripheral package and the waiver files must be declared in the `core-v-mini-mcu.core` manifest:

```yaml
  depend:
       <...>
     - x-heep:ip:<peripheral>

   files:
       <...>
     - hw/ip/<peripheral>/<peripheral>.vlt
```

8. The MCU configuration (mcu_cfg.hjson) must be adapted:

```diff
    peripherals: {
      <...>
+        <peripheral>: {
+            offset:  0x00060000
+            length:  0x00010000
+        }
    }
```

## How to implement the registers

1. Registers must be declared under the `registers:` list in the `<peripheral>.hjson` file. To add a register, append the following:

```
    { name:     "REGISTER_NAME"
      desc:     "Description"
      swaccess: "rw"
      hwaccess: "hro"
      fields: [
        { bits: "15:0",  name: "LSBITS", desc: "Those are the least significant bits." }
        { bits: "31:16", name: "MSBITS", desc: "Those are the most significant bits." }
      ]
    }
```

2. In order to access registers from hardware, the wrapper file (<peripheral>.sv) must be adapted:

a. The module interface must be as follows:

```systemverilog
module <peripheral> #(
    parameter type reg_req_t = logic,
    parameter type reg_rsp_t = logic,
    <...>
) (
    input logic clk_i,
    input logic rst_ni,

    // Register interface
    input  reg_req_t reg_req_i,
    output reg_rsp_t reg_rsp_o,

    // I/Os
    inout  logic your_signal_io,
    <...>
);
```

b. The corresponding package must be imported:

```
import <peripheral>_reg_pkg::*;
```

c. There are two objects used to interact with registers:

* `reg2hw`, that contains signals to read values from registers (hardware readable)
* `hw2reg`, that contains signals to write values into the registers (hardware writable).

d. The signals used to interact with registers are the following:

* `q` contains the current value of a register to be read by hardware
* `d` is written to assign a value to the register
* `de` is an enable signal to get the value written by the hardware from software. It must be asserted to `1` to be able to read it from software.

e. A register with only one filed is accessed by its name and a register with several fields is accessed by its fields.

f. Some examples:

```systemverilog
hw2reg.register.field.de // Data enable signal of a hardware-written field
hw2reg.register.d        // Data to be written on a hardware-written register
reg2hw.register.q        // Data to be read from a register
```

## How to implement an RX window

1. Windows must be declared under the `registers:` list in the `<peripheral>.hjson` file. To add a window, append the following:

```
    { window: {
        name: "RX_WINDOW_NAME"
        items: "1"
        validbits: "32"
        desc: '''Window purpose description'''
        swaccess: "ro"
      }
```

2. An RX window typically looks as follows:

```systemverilog

module <peripheral>_window #(
    parameter type reg_req_t = logic,
    parameter type reg_rsp_t = logic
) (
    input  reg_req_t        rx_win_i,
    output reg_rsp_t        rx_win_o,
    input            [31:0] rx_data_i,
    output logic            rx_ready_o
);

  import <peripheral>_reg_pkg::*;

  logic [BlockAw-1:0] rx_addr;
  logic rx_win_error;

  assign rx_win_error = (rx_win_i.write == 1'b1) && (rx_addr != <peripheral>_reg_pkg::<peripheral>_RXDATA_OFFSET);
  assign rx_ready_o = rx_win_i.valid & ~rx_win_i.write;
  assign rx_win_o.rdata = rx_data_i;
  assign rx_win_o.error = rx_win_error;
  assign rx_win_o.ready = 1'b1;
  assign rx_addr = rx_win_i.addr;

endmodule : <peripheral>_window
```

3. Data is presented on the `rx_data_i` signal and `rx_ready_o` is asserted.

## How to access the peripheral via software

1. Include the following headers to get the peripherals addresses macros and the I/O manipulation functions:

```c
#include "core_v_mini_mcu.h"
#include "<peripheral>_regs.h"

#include "mmio.h"
```

2. The function used to get the base address of the peripheral is the following (the base address is defined in `sw/device/lib/runtime/core_v_mini_mcu.h.tpl`):

```c
mmio_region_t <peripheral>_base_addr = mmio_region_from_addr((uintptr_t)<peripheral>_START_ADDRESS);
```

3. The read and write functions are the following:

```c
mmio_region_write32(pdm2pcm_base_addr, <peripheral>_REGISTERNAME_REG_OFFSET ,<value_to_write>);
uint32_t response = mmio_region_read32(<peripheral>_base_addr, <peripheral>_REGISTERNAME_REG_OFFSET);
```

## How to run a simulation

Use the `hello_world` (`sw/applications/hello_world`) program to quickly test a design.

The hardware platform is contained in the `testharness.sv` (tb/testharness.sv) test bench.

If the GPIOs usage has changed, the testbench must be adapted as follows:

```diff
- .gpio_X_io(gpio[X]),
+ .your_signal_io(gpio[X]),
```

## Add an interrupt
You must register the interrupt in the MCU configuration `mcu_cfg.hjson`.
```diff
    interrupts: {
        number: 64 // Do not change this number!
        list: {
          ...
+          <interrupt identifier>: <interrupt num>
        }
    }
```
and then connect your signal in `peripheral_subsystem.sv` to the plic
```diff
+   assign intr_vector[${interrupts["<interrupt identifier>"]}] = <your signal>;
```

In software the interrupt gets trigger as "external" interrupt see `rv_plic` documentation, your interrupt number to be used in c is automatically added to the `core_v_mini_mcu.h` under the preprosessor define `<YOUR INTERRUPT>` .
